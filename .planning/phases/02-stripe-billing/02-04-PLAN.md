---
phase: 02-stripe-billing
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/api/webhooks/stripe/route.ts
  - lib/subscription.ts
autonomous: true

must_haves:
  truths:
    - "Webhook endpoint receives and verifies Stripe events"
    - "checkout.session.completed creates customer record"
    - "Subscription events sync to database"
    - "invoice.payment_failed logs for notification"
  artifacts:
    - path: "app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler"
      exports: ["POST"]
      min_lines: 80
    - path: "lib/subscription.ts"
      provides: "Subscription sync and status utilities"
      exports: ["syncSubscription", "getSubscriptionStatus"]
  key_links:
    - from: "app/api/webhooks/stripe/route.ts"
      to: "lib/subscription.ts"
      via: "imports sync functions"
      pattern: "import.*subscription"
    - from: "app/api/webhooks/stripe/route.ts"
      to: "stripe.webhooks.constructEvent"
      via: "signature verification"
      pattern: "constructEvent"
---

<objective>
Implement Stripe webhook handler to sync subscription state with database.

Purpose: Webhooks are the source of truth for subscription state. When Stripe events occur (checkout complete, subscription updated, payment failed), the database must be updated to reflect current state.

Output: Working webhook endpoint that syncs subscription data and handles payment failures.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-stripe-billing/02-RESEARCH.md
@lib/stripe.ts (from 02-01)
@lib/supabase/service.ts (from 02-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subscription utilities</name>
  <files>lib/subscription.ts</files>
  <action>
Create utility functions for subscription management:

```typescript
import { createServiceClient } from '@/lib/supabase/service'
import { createClient } from '@/lib/supabase/server'
import Stripe from 'stripe'

export type SubscriptionStatus =
  | 'active'
  | 'trialing'
  | 'grace_period'
  | 'blocked'
  | 'none'

export interface SubscriptionInfo {
  status: SubscriptionStatus
  daysRemaining: number | null
  subscription: any | null
  canSendMessages: boolean
}

// Used by webhooks (admin context)
export async function syncSubscription(subscription: Stripe.Subscription) {
  const supabase = createServiceClient()

  const userId = subscription.metadata.user_id
  if (!userId) {
    console.error('No user_id in subscription metadata')
    return
  }

  await supabase.from('subscriptions').upsert({
    id: subscription.id,
    user_id: userId,
    status: subscription.status,
    price_id: subscription.items.data[0]?.price.id,
    quantity: subscription.items.data[0]?.quantity,
    cancel_at_period_end: subscription.cancel_at_period_end,
    cancel_at: subscription.cancel_at
      ? new Date(subscription.cancel_at * 1000).toISOString()
      : null,
    canceled_at: subscription.canceled_at
      ? new Date(subscription.canceled_at * 1000).toISOString()
      : null,
    current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
    current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
    trial_start: subscription.trial_start
      ? new Date(subscription.trial_start * 1000).toISOString()
      : null,
    trial_end: subscription.trial_end
      ? new Date(subscription.trial_end * 1000).toISOString()
      : null,
  })
}

// Used by webhooks (admin context)
export async function createCustomerRecord(userId: string, stripeCustomerId: string) {
  const supabase = createServiceClient()

  await supabase.from('customers').upsert({
    id: userId,
    stripe_customer_id: stripeCustomerId,
  })
}

// Used by app (user context)
export async function getSubscriptionStatus(userId: string): Promise<SubscriptionInfo> {
  const supabase = await createClient()

  const { data: sub } = await supabase
    .from('subscriptions')
    .select('*')
    .eq('user_id', userId)
    .in('status', ['active', 'trialing', 'past_due', 'canceled'])
    .order('created', { ascending: false })
    .limit(1)
    .single()

  if (!sub) {
    return { status: 'none', daysRemaining: null, subscription: null, canSendMessages: false }
  }

  const now = new Date()

  // Active subscription
  if (sub.status === 'active') {
    return { status: 'active', daysRemaining: null, subscription: sub, canSendMessages: true }
  }

  // In trial
  if (sub.status === 'trialing' && sub.trial_end) {
    const trialEnd = new Date(sub.trial_end)
    const daysRemaining = Math.ceil((trialEnd.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
    return {
      status: 'trialing',
      daysRemaining: Math.max(0, daysRemaining),
      subscription: sub,
      canSendMessages: true
    }
  }

  // Grace period (7 days after trial/subscription end) - per CONTEXT.md
  if (sub.status === 'past_due' || sub.status === 'canceled') {
    const endDate = new Date(sub.current_period_end || sub.trial_end)
    const gracePeriodEnd = new Date(endDate.getTime() + 7 * 24 * 60 * 60 * 1000)

    if (now < gracePeriodEnd) {
      const daysRemaining = Math.ceil((gracePeriodEnd.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
      return {
        status: 'grace_period',
        daysRemaining,
        subscription: sub,
        canSendMessages: false // Per CONTEXT.md: can view but not send during grace
      }
    }
  }

  return { status: 'blocked', daysRemaining: 0, subscription: sub, canSendMessages: false }
}
```
  </action>
  <verify>
File exists at lib/subscription.ts.
TypeScript compiles without errors.
  </verify>
  <done>
Subscription utilities created with sync and status functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook route handler</name>
  <files>app/api/webhooks/stripe/route.ts</files>
  <action>
Create webhook handler following RESEARCH.md patterns. CRITICAL: Use req.text() not req.json() for signature verification.

```typescript
import { headers } from 'next/headers'
import { NextResponse } from 'next/server'
import { stripe } from '@/lib/stripe'
import { syncSubscription, createCustomerRecord } from '@/lib/subscription'
import Stripe from 'stripe'

export async function POST(req: Request) {
  const body = await req.text() // MUST use text(), not json()
  const headersList = await headers()
  const signature = headersList.get('stripe-signature')

  if (!signature) {
    return NextResponse.json({ error: 'Missing signature' }, { status: 400 })
  }

  let event: Stripe.Event

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    )
  } catch (err) {
    console.error('Webhook signature verification failed:', err)
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })
  }

  // Log event for debugging
  console.log(`Stripe webhook: ${event.type}`)

  try {
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as Stripe.Checkout.Session
        const userId = session.metadata?.user_id

        if (userId && session.customer) {
          // Create customer record linking user to Stripe
          await createCustomerRecord(userId, session.customer as string)
        }

        // Subscription will be synced by customer.subscription.created event
        break
      }

      case 'customer.subscription.created':
      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription
        await syncSubscription(subscription)
        break
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription
        await syncSubscription(subscription)
        break
      }

      case 'customer.subscription.trial_will_end': {
        const subscription = event.data.object as Stripe.Subscription
        // TODO: Send email notification (BILL-07)
        // For now, just log
        console.log(`Trial ending soon for subscription: ${subscription.id}`)
        break
      }

      case 'invoice.payment_failed': {
        const invoice = event.data.object as Stripe.Invoice
        // TODO: Send email notification (BILL-07)
        console.log(`Payment failed for invoice: ${invoice.id}`)
        break
      }

      default:
        console.log(`Unhandled event type: ${event.type}`)
    }
  } catch (error) {
    console.error('Webhook handler error:', error)
    // Return 200 to prevent Stripe from retrying
    // Log the error for monitoring
  }

  return NextResponse.json({ received: true })
}
```

Create directory: `mkdir -p app/api/webhooks/stripe`
  </action>
  <verify>
File exists at app/api/webhooks/stripe/route.ts.
TypeScript compiles without errors.
Route handler exports POST function.
  </verify>
  <done>
Webhook route handler created with signature verification and event processing.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Webhook route exists at /api/webhooks/stripe
3. lib/subscription.ts exports syncSubscription and getSubscriptionStatus
4. Webhook uses req.text() for body (not req.json())
5. Signature verification uses stripe.webhooks.constructEvent
</verification>

<success_criteria>
- Webhook endpoint receives POST requests at /api/webhooks/stripe
- Signature verification implemented correctly
- checkout.session.completed creates customer record
- Subscription events sync to database
- Payment failure logged (email notification deferred)
</success_criteria>

<output>
After completion, create `.planning/phases/02-stripe-billing/02-04-SUMMARY.md`
</output>
